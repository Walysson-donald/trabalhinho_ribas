Título: Como analisar a eficiência dos seus algoritmos

Olá, humano (ou não). Bem-vindo à mais uma edição do Turing Talks! Hoje a gente vai falar sobre um assunto muito polêmico, como você pode ver pelo título. É a hora de pegar aquele seu código final, que parece resolver todos os problemas do mundo, e analisar se você está realmente fazendo a coisa do melhor jeito possível ou se tem como deixar ainda mais eficiente.Para isso, vamos começar pelo método mais clássico: analisar a eficiência temporal de algoritmos de ordenação. Esse é um tópico muito importante, uma vez que pode ser aplicado em muitos problemas, mas também é fundamental para ver que, embora todos façam a mesma coisa, não necessariamente tem a mesma eficiência.Uma observação importante antes de começar realmente o trabalho bruto, é que nem sempre um algoritmo ser mais lento é uma coisa negativa. Algumas vezes, algoritmos mais eficientes na questão do tempo demandam uma capacidade computacional (principalmente os recursivos)tão maior que nem compensa deixá-lo mais eficiente. Outro fator também é que, em algumas áreas como segurança da informação, pode ser necessário o uso de algum algoritmo menos eficiente, uma vez que normalmente eles são mais difíceis de serem “quebrados”.Outro detalhe é que eficiência temporal de analisar dados não vem sem consequências, mas logo nós vamos chegar nessa parte.NotaçãoPara análise de algoritmos, a gente se utiliza de uma notação com o nome de Big-O (ou, como é conhecido no Brasil, Grande-O ou ordem). Na matemática, isso basicamente serve para descrever o comportamento de funções quando seu argumento tende a um valor específico ou ao infinito. Nesse caso, para facilitar as contas, nós usamos a tendência para o infinito. Na computação, a ideia é semelhante: é uma notação para classificar o comportamento de determinados algoritmos se comportam diante mudanças no tamanho da entrada.A notação do Big-O mostra a característica das taxas de crescimento. Funções diferentes podem ter a mesma notação Big-O, basta que elas tenham o mesm